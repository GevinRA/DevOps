#!/usr/bin/env node
"use strict";
const argv = require('yargs').argv;
const { exec, spawn } = require('child_process');
const fs = require('fs');
const path = require('path');
const { setBuildContext, bundle, generateManifestTypes, validateControlManifest, copyToOutput, clean } = require('../tasks');
const { getBuildConfiguration } = require('../buildconfiguration');
const { CONFIGURATION_FILE_NAME } = require('../constants');
const VALID_VERBS = ['build', 'rebuild', 'clean', 'start'];
const HELP_MESSAGE = `Not a valid command.\nUsage: pcf-scripts ${VALID_VERBS.map(verb => '[' + verb + ']').join(' ')}`;
const args = process.argv.slice(2);
let configuration;
if (args.length === 0 || !VALID_VERBS.includes(args[0])) {
    console.log(HELP_MESSAGE);
    process.exit(0);
}
try {
    configuration = getBuildConfiguration(path.resolve('.', CONFIGURATION_FILE_NAME), () => { return argv; });
    setBuildContext(configuration);
}
catch (err) {
    onBuildError(err);
}
const verbArg = args[0];
console.log(`Kicking off PCF ${verbArg} process...`);
doTask(verbArg).catch((err) => onBuildError(err)).then((resolve) => {
    console.log(`[Done] ${verbArg} succeeded.`);
});
function doTask(verb) {
    switch (verb) {
        case 'build':
            return buildTask(false);
        case 'rebuild':
            return clean().then(() => buildTask(false));
        case 'clean':
            return clean();
        case 'start':
            return buildTask(false).then(startHarness);
        default:
            return buildTask(false);
    }
}
function buildTask(isWatch) {
    return validateControlManifest()
        .then(generateManifestTypes)
        .then(() => bundle(isWatch))
        .then(copyToOutput);
}
function onBuildError(error) {
    // Promise.catch will catch both thrown errors and rejected promise; print accordingly
    console.error((`[Build failed] because of the following error:\n${error && error.message ? error.message : error}\n`));
    process.exit(1);
}
function startHarness() {
    const controls = fs.readdirSync(configuration.outDir);
    if (controls.length === 0) {
        console.error('Please build control first before running npm start.');
        process.exit(1);
    }
    return new Promise((resolve, reject) => {
        const outputDir = path.join(configuration.outDir, controls[0]);
        // spawn a child process of pcf-start to launch the harness locally
        const pcfStartCmd = spawn('cmd', ['/c', `pcf-start --codePath ${outputDir}`]);
        pcfStartCmd.stdout.on('data', (data) => {
            console.log(data.toString());
        });
        pcfStartCmd.stderr.on('data', (data) => {
            console.log(data.toString());
        });
        pcfStartCmd.on('close', (code) => {
            if (code !== 0) {
                return reject(`pcf-start exited with code ${code}`);
            }
            else {
                return resolve();
            }
        });
    });
}
