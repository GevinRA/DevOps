"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class ManifestSchemaValidator {
    constructor(data) {
        this.required_attribs_control = ['namespace', 'constructor', 'version', 'display-name-key'];
        this.required_attribs_code = ['path', 'order'];
        this.required_attribs_property_dataset_enum = ['name', 'display-name-key'];
        this.allowed_control_type = new Set(['virtual', 'standard']);
        this.allowed_usage_type = new Set(['bound', 'input', 'output']);
        this.allowed_data_type = new Set([
            'Whole.None',
            'TwoOptions',
            'DateAndTime.DateOnly',
            'DateAndTime.DateAndTime',
            'Decimal',
            'Enum',
            'FP',
            'Multiple',
            'Currency',
            'OptionSet',
            'SingleLine.Email',
            'SingleLine.Text',
            'SingleLine.TextArea',
            'SingleLine.URL',
            'SingleLine.Ticker',
            'SingleLine.Phone'
        ]);
        this.parsedJson = data;
        this.errors = [];
    }
    validateManifestAgainstXSD() {
        if (!this.parsedJson.manifest) {
            return ['<manifest> element missing.'];
        }
        if (!this.parsedJson.manifest.control) {
            return ['<control> element missing.'];
        }
        this.validateControlNode(this.parsedJson.manifest.control);
        const controlNode = this.parsedJson.manifest.control[0];
        if (!controlNode.resources) {
            this.errors.push('<resources> element missing.');
        }
        else {
            this.validateResourcesNode(controlNode.resources);
        }
        if (controlNode.property) {
            this.validatePropertyNodes(controlNode.property);
        }
        if (controlNode['data-set']) {
            this.validateDatasetNodes(controlNode['data-set']);
        }
        return this.errors;
    }
    validateControlNode(controlNodes) {
        if (controlNodes.length > 1) {
            this.errors.push('<control> element: only one allowed.');
        }
        const controlNode = controlNodes[0];
        this.checkRequiredAttribs(this.required_attribs_control, controlNode, 'control');
        const controlType = controlNode.$['control-type'];
        if (controlType) {
            this.checkValue('control', 'control-type', controlType, this.allowed_control_type);
        }
    }
    validateResourcesNode(resources) {
        if (resources.length > 1) {
            this.errors.push('<resources> element: only one allowed.');
        }
        const resourcesNode = resources[0];
        if (!resourcesNode['code']) {
            this.errors.push('<resources> element: child element <code> missing.');
            return;
        }
        if (resourcesNode['code'].length > 1) {
            this.errors.push('<code> element: only one allowed.');
        }
        this.checkRequiredAttribs(this.required_attribs_code, resourcesNode['code'][0], 'code');
    }
    validatePropertyNodes(propertyNodes, isPropertySet) {
        const key = isPropertySet ? 'property-set' : 'property';
        propertyNodes.forEach(prop => {
            this.checkRequiredAttribs(this.required_attribs_property_dataset_enum, prop, key);
            if (prop.$['of-type']) {
                this.checkValue(key, 'of-type', prop.$['of-type'], this.allowed_data_type);
            }
            if (prop.$['usage']) {
                this.checkValue(key, 'usage', prop.$['usage'], this.allowed_usage_type);
            }
            // validate Enum
            if (prop.value) {
                prop.value.forEach(val => {
                    this.checkRequiredAttribs(this.required_attribs_property_dataset_enum, val, 'enum');
                });
            }
        });
    }
    validateDatasetNodes(datasetNodes) {
        datasetNodes.forEach(dataset => {
            this.checkRequiredAttribs(this.required_attribs_property_dataset_enum, dataset, 'data-set');
            if (dataset['property-set']) {
                this.validatePropertyNodes(dataset['property-set'], true);
            }
        });
    }
    // check whether the value of an attribute is one of the allowed ones
    checkValue(element, attrib, value, allowedValues) {
        if (!allowedValues.has(value)) {
            const allowedValuesInString = Array.from(allowedValues).join(', ');
            this.errors.push(`<${element}> element: attribute "${attrib}" can only be one of the following values: ${allowedValuesInString}.`);
        }
    }
    // check whether all required attributes are present in a given element
    checkRequiredAttribs(requiredAttribs, node, elementName) {
        requiredAttribs.forEach(attrib => {
            // unfortunately constructor is a javascript reserved word so even if Control node doesn't contain
            // the required "constructor" attribute, control.$.constructor still returns a function object.
            // added check for this edge case
            if (!node.$[attrib] || typeof node.$[attrib] === 'function') {
                this.errors.push(`<${elementName}> element: required attribute "${attrib}" missing.`);
            }
        });
    }
}
exports.ManifestSchemaValidator = ManifestSchemaValidator;
