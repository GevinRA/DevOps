"use strict";
/// <reference path="./typings/buildconfig.d.ts"/>
Object.defineProperty(exports, "__esModule", { value: true });
const controlcontext_1 = require("./controlcontext");
const fs = require('fs');
const path = require('path');
const { MANIFEST_INPUT_FILE_NAME } = require('./constants');
// Context for building PCF controls
class BuildContext {
    constructor(config) {
        this.config = config;
        if (config.controlsRoot) {
            this.controls = this.getControls();
        }
    }
    // Gets the controls root directory
    getControlsRoot() {
        return this.config.controlsRoot;
    }
    // Gets the output directory
    getOutDir() {
        return this.config.outDir;
    }
    // Gets the output directory
    getBuildMode() {
        return this.config.buildMode;
    }
    // Maps the specified callback for each control under the root directory
    mapControls(callback) {
        if (!this.config.controlsRoot) {
            return Promise.reject("Build configuration value for 'controlsRoot' not defined.");
        }
        if (!this.controls || this.controls.length === 0) {
            return Promise.reject(`No control is found that contains a ${MANIFEST_INPUT_FILE_NAME}.`);
        }
        const results = this.controls.map((value) => { return callback(value); });
        return Promise.all(results);
    }
    // Gets the list of controls under the controls root directory
    getControls() {
        if (!this.config.controlsRoot) {
            return [];
        }
        // Exclude node_modules and outdir from control folder search
        const exludedFolders = [path.join(this.config.controlsRoot, 'node_modules'), this.config.outDir];
        let controls = BuildContext.findControlFolders(this.config.controlsRoot, exludedFolders);
        return controls.map((controlPath) => {
            return new controlcontext_1.ControlContext(controlPath);
        });
    }
    // Searches the provided directory for control folders.
    // A control folder is defined as containing a ControlManifest.Input.xml file.
    static findControlFolders(cwd, excludedFolders) {
        let results = [];
        if (fs.existsSync(path.join(cwd, MANIFEST_INPUT_FILE_NAME))) {
            results.push(cwd);
            return results;
        }
        let folders = fs.readdirSync(cwd).filter(function (file) {
            return fs.statSync(path.join(cwd, file)).isDirectory();
        });
        folders.forEach((folder) => {
            const currentFolder = path.join(cwd, folder);
            if (excludedFolders && excludedFolders.find((elem) => elem === currentFolder)) {
                return;
            }
            else {
                results = results.concat(this.findControlFolders(currentFolder));
            }
        });
        return results;
    }
}
exports.BuildContext = BuildContext;
