"use strict";
/// <reference path="../../common/typings/controlmanifest.d.ts"/>
Object.defineProperty(exports, "__esModule", { value: true });
const { Builder } = require('xml2js');
const flatMap = require('lodash/flatMap');
const { CODE_ELEM_NAME, LIBRARY_ELEM_NAME } = require('./constants');
class ControlManifest {
    constructor(manifestObj) {
        this.data = manifestObj;
    }
    getControlVersion() {
        return this.data.manifest.control.$.version;
    }
    setControlVersion(newVersion) {
        this.data.manifest.control.$.version = newVersion;
    }
    getManifestData() {
        return this.data;
    }
    getNamespace() {
        return this.data.manifest.control.$.namespace;
    }
    getConstructor() {
        return this.data.manifest.control.$.constructor;
    }
    getCodePath() {
        return this.data.manifest.control.resources[CODE_ELEM_NAME][0].$.path;
    }
    // Return an array of paths of the control's resources relative to that control's root folder
    // includeTs flag determines whether <code> element's path will be included
    getResources(includeTs) {
        const resources = this.data.manifest.control.resources;
        let pathsCollection = [];
        Object.keys(resources).forEach(resourceType => {
            let paths;
            if (resourceType !== LIBRARY_ELEM_NAME) {
                paths = (resourceType === CODE_ELEM_NAME && !includeTs) ? [] : resources[resourceType].map((resource) => resource.$.path);
            }
            else {
                paths = flatMap(resources[resourceType], (resource) => resource.packaged_library.map((packagedLib) => packagedLib.$.path));
            }
            pathsCollection.push(...paths);
        });
        return pathsCollection;
    }
    // Build xml string from the ControlManifest's json object
    getManifestXmlString() {
        const jsonToXmlbuilder = new Builder();
        const xml = jsonToXmlbuilder.buildObject(this.data);
        return xml;
    }
}
exports.ControlManifest = ControlManifest;
