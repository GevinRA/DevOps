"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require('fs');
const path = require('path');
const { Errors } = require('./errors');
const { DEFAULT_OUT_DIR, DEFAULT_BUILD_MODE } = require('./constants');
// Gets the build configuration from file or command line args
// The following command line args are supported:
// --controlsRoot [path]  specifies the root path for controls
// --outDir [path] specifies the build output path
// --buildMode [production | development]  specifies build mode
function getBuildConfiguration(configPath, argsParser) {
    const defaultConfig = { 'controlsRoot': '.', 'outDir': DEFAULT_OUT_DIR, 'buildMode': DEFAULT_BUILD_MODE };
    let fileConfig;
    if (configPath) {
        fileConfig = JSON.parse(fs.readFileSync(configPath));
    }
    let commandLineConfig;
    if (argsParser) {
        let argv = argsParser();
        if (argv.controlsRoot || argv.outDir || argv.buildMode) {
            commandLineConfig = {};
            commandLineConfig.controlsRoot = argv.controlsRoot;
            commandLineConfig.outDir = argv.outDir;
            commandLineConfig.buildMode = argv.buildMode;
        }
    }
    if (fileConfig && commandLineConfig) {
        if (fileConfig.controlsRoot && commandLineConfig.controlsRoot) {
            if (!ArePathsEqual(fileConfig.controlsRoot, commandLineConfig.controlsRoot)) {
                throw new Error(Errors.mismatched_configuration('controlsRoot', configPath));
            }
        }
        if (fileConfig.outDir && commandLineConfig.outDir) {
            if (!ArePathsEqual(fileConfig.outDir, commandLineConfig.outDir)) {
                throw new Error(Errors.mismatched_configuration('outDir', configPath));
            }
        }
        if (fileConfig.buildMode && commandLineConfig.buildMode && fileConfig.buildMode !== commandLineConfig.buildMode) {
            throw new Error(Errors.mismatched_configuration('buildMode', configPath));
        }
    }
    const config = defaultConfig;
    config.buildMode = fileConfig && fileConfig.buildMode
        ? fileConfig.buildMode : commandLineConfig && commandLineConfig.buildMode
        ? commandLineConfig.buildMode : config.buildMode;
    config.outDir = fileConfig && fileConfig.outDir
        ? fileConfig.outDir : commandLineConfig && commandLineConfig.outDir
        ? commandLineConfig.outDir : config.outDir;
    config.controlsRoot = fileConfig && fileConfig.controlsRoot
        ? fileConfig.controlsRoot : commandLineConfig && commandLineConfig.controlsRoot
        ? commandLineConfig.controlsRoot : config.controlsRoot;
    if (config.buildMode !== 'development' && config.buildMode !== 'production') {
        throw new Error(Errors.unsupported_build_mode(config.buildMode));
    }
    return config;
}
exports.getBuildConfiguration = getBuildConfiguration;
function ArePathsEqual(path1, path2) {
    if (path1 && path2) {
        const resolvedPath1 = path.resolve(path1);
        const resolvedPath2 = path.resolve(path2);
        const parsedPath1 = path.parse(resolvedPath1);
        const parsedPath2 = path.parse(resolvedPath2);
        // This check will need to be updated when running on file systems that care about case.
        return (parsedPath1.root.toLowerCase() === parsedPath2.root.toLowerCase()) &&
            (path.relative(parsedPath1.root, resolvedPath1).toLowerCase() === path.relative(parsedPath2.root, resolvedPath2).toLowerCase());
    }
    return path1 === path2;
}
