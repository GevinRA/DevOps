"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const buildcontext_1 = require("./buildcontext");
const webpackconfig_1 = require("./webpackconfig");
const fs = require('fs-extra');
const path = require('path');
const webpack = require('webpack');
const { BUNDLE_NAME } = require('./constants');
function setBuildContext(config) {
    exports.buildContext = new buildcontext_1.BuildContext(config);
}
exports.setBuildContext = setBuildContext;
// bundle source code using webpack
function bundle(isWatch) {
    console.log(`[Build task]: Compiling and bundling control${isWatch ? ' in watch mode' : ''}...`);
    if (!exports.buildContext) {
        return Promise.reject('Build context not set.  Call setBuildContext() with a valid build config');
    }
    const buildMode = exports.buildContext.getBuildMode();
    const outDir = exports.buildContext.getOutDir();
    if (!outDir) {
        return Promise.reject('Output directory not specified in build config.');
    }
    return exports.buildContext.mapControls((control) => {
        const controlOutputDir = path.resolve(outDir, control.getControlFolderName());
        const config = webpackconfig_1.getWebpackConfig(control, controlOutputDir, buildMode, isWatch);
        const bundlePath = path.join(controlOutputDir, BUNDLE_NAME);
        fs.ensureDirSync(controlOutputDir);
        return new Promise((resolve, reject) => webpack(config, (error, stats) => {
            const stub = webpackconfig_1.getNamespaceStub(control.getControlNamespace(), control.getControlName());
            fs.appendFileSync(bundlePath, stub, 'utf8');
            console.log(`[Build stats]:\n${stats.toString({ chunks: false })}`);
            if (error) {
                return reject(error);
            }
            else if (stats.hasErrors()) {
                return reject('Bundling Error: See errors in build stats above.');
            }
            return resolve();
        }));
    });
}
exports.bundle = bundle;
// generates control manifest types
function generateManifestTypes(cb) {
    console.log('[Build task]: Generating manifest types...');
    if (!exports.buildContext) {
        return Promise.reject('Build context not set.  Call setBuildContext() with a valid build config');
    }
    return exports.buildContext.mapControls((control) => {
        return Promise.resolve(control.generateManifestTypes());
    });
}
exports.generateManifestTypes = generateManifestTypes;
// copy resources (except ts source code) and processed manifest to <outDir>/<controlName>
function copyToOutput(cb) {
    console.log('[Build task]: Generating build outputs...');
    if (!exports.buildContext) {
        return Promise.reject('Build context not set. Call setBuildContext() with a valid build config');
    }
    const outDir = exports.buildContext.getOutDir();
    if (!outDir) {
        return Promise.reject('Output directory not specified in build config.');
    }
    return exports.buildContext.mapControls((control) => {
        return control.copyResourcesToOutdir(outDir);
    });
}
exports.copyToOutput = copyToOutput;
// validate ControlManifest.Input.xml
function validateControlManifest(cb) {
    console.log('[Build task]: Validating control manifest...');
    if (!exports.buildContext) {
        return Promise.reject('Build context not set.  Call setBuildContext() with a valid build config');
    }
    return exports.buildContext.mapControls((control) => {
        const result = control.validateManifest();
        if (!result.success) {
            return Promise.reject(`Manifest Validation Error:\n${result.msg}`);
        }
        else {
            return Promise.resolve();
        }
    });
}
exports.validateControlManifest = validateControlManifest;
// clean all possible build outputs
function clean(cb) {
    console.log('[Clean task]: Cleaning build outputs...');
    if (!exports.buildContext) {
        return Promise.reject('Build context not set.  Call setBuildContext() with a valid build config');
    }
    const outDir = exports.buildContext.getOutDir();
    if (!outDir) {
        return Promise.reject('Output directory not specified in build config.');
    }
    fs.emptyDirSync(outDir);
    return Promise.resolve();
}
exports.clean = clean;
