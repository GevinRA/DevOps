"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const controlmanifest_1 = require("./controlmanifest");
const manifesttypesgenerator_1 = require("./manifesttypesgenerator");
const ts = require("typescript");
const manifestprocessor_1 = require("./manifestprocessor");
const manifestschemavalidator_1 = require("./manifestschemavalidator");
const fs = require('fs-extra');
const path = require('path');
const { parseString } = require('xml2js');
const { MANIFEST_INPUT_FILE_NAME, MANIFEST_TYPE_FILE_NAME, PROCESSED_MANIFEST_FILE_NAME, TYPING_FOLDER_NAME } = require('./constants');
class ControlContext {
    constructor(controlPath) {
        this.controlPath = controlPath;
        this.loadControlManifest();
        this.manifestTypesGenerator = new manifesttypesgenerator_1.ManifestTypesGenerator();
        this.manifestProcessor = new manifestprocessor_1.ManifestProcessor(this.manifest.getManifestData());
    }
    getControlManifest() {
        return this.manifest;
    }
    getControlName() {
        return this.manifest.getConstructor();
    }
    getControlFolderName() {
        return path.basename(this.controlPath);
    }
    getControlPath() {
        return this.controlPath;
    }
    getControlNamespace() {
        return this.manifest.getNamespace();
    }
    getCodeRelativePath() {
        return this.manifest.getCodePath();
    }
    // Generates ManifestTypes.d.ts file from control manifest
    generateManifestTypes() {
        const comment = `/*\n*This is auto generated from the ControlManifest.Input.xml file\n*/\n\n` +
            `// Define IInputs and IOutputs Type. They should match with ControlManifest.\n`;
        const code = comment + this.manifestTypesGenerator.generateManifestTypes(this.manifest.data);
        const generatedDir = path.join(this.controlPath, TYPING_FOLDER_NAME);
        fs.ensureDirSync(generatedDir);
        fs.writeFileSync(path.join(generatedDir, MANIFEST_TYPE_FILE_NAME), code);
    }
    // TODO: refactor - extract validateManifest to a separate class
    validateManifest() {
        // check whether all properties and property-sets are using an existing type group
        const controlNode = this.manifest.data.manifest.control;
        if (controlNode['type-group']) {
            // check all properties
            if (controlNode.property) {
                let i;
                for (i = 0; i < controlNode.property.length; i++) {
                    if (!controlNode.property[i].$['of-type-group']) {
                        continue;
                    }
                    const res = this.validateTypeGroup(controlNode['type-group'], controlNode.property[i]);
                    if (!res.success) {
                        return res;
                    }
                }
            }
            // check all property-sets of all datasets
            if (controlNode['data-set']) {
                let i, j;
                const dataSets = controlNode['data-set'];
                for (i = 0; i < dataSets.length; i++) {
                    if (dataSets[i]['property-set']) {
                        const props = dataSets[i]['property-set'];
                        for (j = 0; j < props.length; j++) {
                            const res = this.validateTypeGroup(controlNode['type-group'], props[j]);
                            if (!res.success) {
                                return res;
                            }
                        }
                    }
                }
            }
        }
        // Validate <code> element under <resource>
        const codePath = path.resolve(this.controlPath, controlNode.resources['code'][0].$.path);
        const fileType = path.extname(codePath);
        if (fileType !== '.ts') {
            return {
                success: false,
                msg: [`Code file needs to be a typescript (.ts). Code file ${codePath} has a different file extension.`]
            };
        }
        else if (!fs.existsSync(codePath)) {
            return {
                success: false,
                msg: [`Code file path ${codePath} does not exist.`]
            };
        }
        // Make sure control doesn't use internal module and only exports one component
        let validationRslt = { success: true };
        const program = ts.createProgram([codePath], {});
        let numExported = 0;
        const srcFiles = program.getSourceFiles().filter(srcFile => !srcFile.isDeclarationFile && path.resolve(srcFile.fileName) === codePath);
        srcFiles.forEach(srcFile => {
            srcFile.forEachChild((node) => {
                if (node.kind === ts.SyntaxKind.ModuleDeclaration) {
                    validationRslt = {
                        success: false,
                        msg: ['Control uses internal module.']
                    };
                    return;
                }
                if (node.modifiers) {
                    node.modifiers.forEach((modifier) => {
                        if (modifier.kind === ts.SyntaxKind.ExportKeyword) {
                            numExported++;
                            if (numExported > 1) {
                                validationRslt = {
                                    success: false,
                                    msg: ['More than one exported component.']
                                };
                                return;
                            }
                        }
                    });
                }
            });
        });
        return validationRslt;
    }
    // Copy all control's resources (except code) to output folder; process names if necessary
    copyResourcesToOutdir(outDir) {
        const controlOutputDir = path.join(outDir, this.getControlFolderName());
        fs.ensureDirSync(controlOutputDir);
        // process and copy ControlManifest.Input.xml
        const result = this.manifestProcessor.getProcessedManifest();
        const processedManifest = result.processedManifest;
        const resourcesMap = result.resourcesMap;
        const processedXmlString = processedManifest.getManifestXmlString();
        const processedManifestPath = path.join(controlOutputDir, PROCESSED_MANIFEST_FILE_NAME);
        fs.writeFileSync(processedManifestPath, processedXmlString);
        // copy all resources except <code> which gets webpacked
        const relativePaths = this.getControlManifest().getResources(false);
        const copyResourcesResults = relativePaths.map((relativePath) => {
            const fileName = resourcesMap[relativePath];
            const desPath = path.join(controlOutputDir, fileName);
            const resourcePath = path.resolve(this.getControlPath(), relativePath);
            if (fs.existsSync(resourcePath)) {
                fs.copyFileSync(resourcePath, desPath);
                return Promise.resolve();
            }
            else {
                return Promise.reject(`Resouce file ${resourcePath} not found.`);
            }
        });
        return Promise.all(copyResourcesResults);
    }
    // Loads the control manifest from the specified control path
    loadControlManifest() {
        const manifestPath = path.join(this.controlPath, MANIFEST_INPUT_FILE_NAME);
        const rawXml = fs.readFileSync(manifestPath);
        const data = {};
        parseString(rawXml, (err, result) => {
            if (err) {
                throw new Error(`Manifest Parsing Error: ${err.message}.`);
            }
            if (!result) {
                throw new Error('Manifest Parsing Error: ControlManifest.Input.xml is empty.');
            }
            // XSD validation on the raw json parsed from xml
            const xsdValidator = new manifestschemavalidator_1.ManifestSchemaValidator(result);
            const validationErrors = xsdValidator.validateManifestAgainstXSD();
            if (validationErrors.length > 0) {
                throw new Error(`Manifest Schema Validation Errors:\n${validationErrors.join('\n')}`);
            }
            // flatten all explicit arrays
            const controlNode = result.manifest.control[0];
            data.manifest = { control: controlNode };
            data.manifest.control.resources = controlNode.resources[0];
        });
        this.manifest = new controlmanifest_1.ControlManifest(data);
    }
    // Verify a property element actually uses an existing type group in type-group element
    validateTypeGroup(typeGroups, prop) {
        const typeGroupName = prop.$['of-type-group'];
        const validTypeGroup = typeGroups.filter(group => group.$.name === typeGroupName);
        if (validTypeGroup.length !== 1) {
            const errorMsg = `The manifest uses a 'type-group' called ${typeGroupName} but no or`
                + ` more than one 'type-group' of such name exists!`;
            return {
                success: false,
                msg: [errorMsg]
            };
        }
        return { success: true };
    }
}
exports.ControlContext = ControlContext;
